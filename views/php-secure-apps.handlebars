<div class="wrapper">
    <div class="content">
        <h1 class="welcome">How to Secure Web Applications</h1>

<p>The examples provided are in PHP but every concept applies to all web applications unless noted such as in other languages/frameworks (Node.js, ASP, etc.).</p>

<strong>Securing Passwords</strong>
<hr />
<p><strong>Problem:</strong> Passwords stored in plaintext or with an insecure algorithm may allow hackers who have accessed the database to compromise users' accounts on the website or possibly on other websites if they use the same passwords.</p>

<p><strong>Solution:</strong> I have already written a guide on securing passwords using Blowfish. You can find that guide <a href="alternatives-storing-passwords.php">here</a>.</p>

<p>For anyone not using Blowfish, there are some points you should follow:</p>
<ul>
<li>Force users to have long, unique passwords - Relatively simple passwords are easier to break or guess.</li>
<li>Have a long, random salt generated - This helps against bruteforces and rainbow tables.</li>
<li>Use a slow algorithm - This will slow hackers down when trying to bruteforce the passwords. Blowfish is good for this, but you could also use the popular SHA-family functions with several rounds.</li>
</ul>

<strong>SQL Injection</strong>
<hr />
<p><strong>Problem:</strong> Allowing unescaped query data to be inserted into an SQL query can allow a hacker to exploit the database. Take the following code for example:</p>
<pre class="brush: php">$query = &quot;SELECT * FROM members_table WHERE username = '$username'&quot;;
$result = mysql_query($query);
// ...</pre>
<p>Now let's say a user intending to exploit this weakness puts <strong>' OR 1=1;\x00</strong> for the form's data. This transforms the query into:</p>
<pre class="brush: sql">SELECT * FROM members_table WHERE username = '' OR 1=1;</pre>
<p>Since 1=1 will always evaluate to true, the WHERE clause becomes useless and all users in the members_table are selected and returned, including moderators or administrators. But this is only the basics of what users can do to manipulate the query; other attacks can include executing other SQL commands such as: DROP, UPDATE, INSERT INTO, etc.</p>

<p><strong>Solution:</strong> The problem with the form earlier is that it didn't properly escape the data being sent to the query. The culprit was the lone single-quote (') which, when embedded in the query, ended the username string and allowed a valid SQL condition to be placed. Note that the single-quote isn't the only dangerous character which needs to be escaped, different database systems require certain characters to be escaped otherwise they can compromise the query like the single-quote did. Additionally, prepared statements can aso be used validate the data.</p>

<p>A solution to the problem is to use the <em>*_real_escape_string()</em> functions provided by the database drivers in the PHP library. For example, when using the MySQL driver you should use the <em>mysql_real_escape_string()</em> function before passing user-submitted data to be embedded in a query. When using SQLite, you would use <em>sqlite_escape_string()</em>. These functions should be used instead of a function such as <em>addslashes()</em> because these driver-specific functions protect against all characters that are considered dangerous for the database system. For instance, mysql_real_escape_string() protects against: \x00, \n, \r, \, ', " and \x1a (NUL, new lines, backslash, quotes, and EOF marker). The following updated code would protect the query from SQL injection:</p>
<pre class="brush: php">$username = mysql_real_escape_string($username);
$query = &quot;SELECT * FROM members_table WHERE username = '$username'&quot;;
$result = mysql_query($query);
// ...</pre>
<p>Trying to use the same input in the form earlier would execute the following query:</p>
<pre class="brush: sql">SELECT * FROM members_table WHERE username = '\' OR 1=1; \0'</pre>
<p>As you can see, this creates no danger to the database and the data is evaluated as a string.</p>

<p>The other solution is a more modern approach and uses prepared statements. Prepared statements are pre-compiled queries that are more efficient for databases to execute when a query is being used multiple times. They also provide placeholders so the data being embedded can be properly escaped. This can be accomplished using an abstraction-layer such as PDO:</p>
<pre class="brush: php">$query = &quot;SELECT * FROM members_table WHERE username = :user&quot;;
$stmt = $dbh-&gt;prepare($query);
$stmt-&gt;bindValue(':user', $username, PDO::PARAM_STR);
$stmt-&gt;execute();
// ...</pre>
<p>Using placeholders and binding a value to the placeholder allows the data in the $username variable to be properly escaped. Also, PDO adds the quotes to the query since the placeholder is a string. </p>

<p>Other abstraction-layers and newer database drivers such as MySQLi provide prepared statements.</p>

<strong>Session Fixation</strong>
<hr />
<p><strong>Problem:</strong> Session fixation is a form of <em>session hijacking</em> where a malicious user learns the session ID of another user and attempts to use it to gain access as that user. For example, this occurs if a victim user sends a link containing their session ID to a malicious user like so:</p>
<blockquote>Hey dude! I just read this really cool article about turtles here at http://turtlez.com/about.php?PHPSESSID=1234</blockquote>
<p>Usually you will see these sort of links generated for guests viewing the webpage of a site which generates a session for the guest viewing their website. But what happens if the victim logs in and their session isn't changed? This means when the malicious user visits the site again with the same session ID as the victim who logged in, the server assumes this is the same person. The same could happen if the malicious user sent the link with a defined session ID to a victim. Take for example the following scenario:</p>
<blockquote>Evil Anthony: hey, check out this site that you're an administrator on http://mysite.com/index.php?PHPSESSID=lol123<br />
Good Anthony: Oh, hey thanks!<br />
Evil Anthony: don't forget to login so I can fixate your session and eventually login as you because the software is vulnerable.. MUAHAHAHAHA!! Uh, I mean I have to go!! uh cya.<br />
Good Anthony: sounds like a plan! cya later m8. brb logging in.</blockquote>
<p>Once the good Anthony logged in to this website he has special permissions in, evil Anthony decides to visit the same site with the same session ID impersonating the good Anthony wrecking havoc on the website.</p>

<p>This same process can be done with cookie-based sessions where the malicious user uses a technique such as XSS to get the cookie data of the user and subsequently modifies his/her cookie to reflect the session ID of the victim.</p>

<p><strong>Solution:</strong> A solution to this problem is very simple and can be done during login. When the victim user logs in, you can regenerate a session ID so that the ID they had as a guest no longer exists and the malicious user who has the victim's guest ID can not use it to impersonate the victim. An example of a login system vulnerable to a session fixation attack looks like:</p>
<pre class="brush: php">session_start();

function doLogin() {
    // Do other stuff...
    $_SESSION['loggedIn'] = true;
}

if ($_SESSION['loggedIn']) {
    echo 'Welcome user!';
} else {
    echo 'Welcome guest.';
    // Pretend they automatically login.
    doLogin();
}</pre>
<p>You can use the <em>session_regenerate_id();</em> function to regenerate a session ID and optionally destroy all session data associated with it:</p>
<pre class="brush: php">session_start();

function doLogin() {
    // Do other stuff...

    // Set a new session ID for the user.
    session_regenerate_id();
    $_SESSION['loggedIn'] = true;
}

if ($_SESSION['loggedIn']) {
    echo 'Welcome user!';
} else {
    echo 'Welcome guest.';
    // Pretend they automatically login.
    doLogin();
}</pre>

<p>What happens when a malicious user gets a hold of the session ID while the victim is already logged in? There are a number of ways to combat this problem:</p>
<ul>
<li>Check the User-Agent, Referrer, or IP of the user before loading the page to be sure it is the same user.</li>
<li>Used timed sessions which expire after a certain amount of time.</li>
<li>Regenerate a session ID on each new page load for a logged in user (with guests this isn't necessary).</li>
</ul>

<strong>Cross-Site Request Forgery (CSRF/XSRF)</strong>
<hr />
<p><strong>Problem:</strong> A CSRF attack is an attack where a malicious user makes a request to a website on behalf of a user with the permission to make the request. For example, a CSRF attack can be used on a victim where they log themselves out. It is possible for this attack to occur without the victim even knowing it did by taking advantage of some HTML code. Say for instance the victim is viewing a website badsite.com which contains an image tag in the body that looks like this:</p>
<pre class="brush: xml">&lt;img src=&quot;http://mysite.com/index.php?action=logout&quot; /&gt;</pre>
<p>Because the user is (assumed) to be logged in on mysite.com, his/her browser makes a request to that website assuming an image will be read, but instead there is no image and the request has been made. Because this request is valid and the user has permission on that website to log out, the victim is logged out. This method applies to any element which can make a request to another server or even using some Javascript. This attack has been used to buy products from online stores without the user even knowing about it!</p>

<p><strong>Solution:</strong> Require the user to provide a <em>security token</em> on actions where it can be processed with a link. For example, if the logout function required the victim to go to an intermediary page to logout, the original link wouldn't work. However, for an action where it is as simple as clicking a link, force the user to provide a security token the attacker cannot know about to make sure the action is legitimate.</p>

<p>For forms, you can start by providing a hidden input field containing the token:</p>
<pre class="brush: xml">&lt;form action=&quot;http://mysite.com/buy.php&quot; method=&quot;get&quot;&gt;
   &lt;input type=&quot;text&quot; name=&quot;product&quot; /&gt;
   &lt;input type=&quot;text&quot; name=&quot;quantity&quot; /&gt;
   &lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; value=&quot;fdsu9r2023h9fsgg0j&quot; /&gt;
&lt;/form&gt;</pre>
<p>The security token used in the form is generated server-sided. A common method is to make this randomized. SMF uses the session ID along with a pseudo-random number generator such as mt_rand() to provide a unique, random token. All that needs to be checked when logging out is the valid security token:</p>
<pre class="brush: php">function doLogout() {
   // The token they sent was not send or it did not match the global security token.
   // Do not logout.
   if (!isset($_REQUEST['csrf_token']) || strcmp($_REQUEST['csrf_token'], $global_csrf_token) !== 0)
      return false;

   // Else, logout... destroy session... etc.
   return true;
}</pre>

<strong>Cross-Site Scripting (XSS)</strong>
<hr />
<p><strong>Problem:</strong> Cross-site scripting is a method malicious users use to take sensitive information such as cookie data. This sort of method involves embedding Javascript in the webpage. This is common in web applications where users can submit a form which shows data on the webpage, such as a forum where users post topics or replies to them. A vulnerable form takes the input given to it and outputs the data directly without escaping it or converting the character entities.</p>

<p><strong>Solution:</strong> The solution is very simple and only requires that you convert the raw data into <em>character entities</em>. Character entities are representations of the characters themselves that can be safely viewed on a webpage. For example, say a malicious user entered the following Javascript in a form:</p>
<pre class="brush: js">&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Vulnerable.&quot;);&lt;/script&gt;</pre>
<p>In a vulnerable script, this data will be embedded in the webpage as a typical comment (or whatever the app is intended to do to display the data). All users viewing the webpage will get a Javascript popup because the script is executed by the browser.</p>

<p>In PHP, you can use the <em>htmlspecialchars()</em> or <em>htmlentities()</em> functions to safely convert any special characters into their entity equivalents. Be sure to pass the ENT_QUOTES to the flags parameter for each function to convert quotes as well. Therefore, any data which can contain HTML data should be passed through one of these functions, such as comments.</p>
<pre class="brush: php">$message = '&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Vulnerable.&quot;);&lt;/script&gt;';
echo htmlspecialchars($message, ENT_QUOTES);</pre>
<p>This will print:</p>
<blockquote>&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Vulnerable.&quot;);&lt;/script&gt;</blockquote>
<p>Which is safe to view and looks perfectly fine once rendered by the browser.</p>

<p>*Note: Don't forget to escape the data if it goes into a database!</p>


<p>Thanks for reading!</p>

    </div>
    <div class="push"></div>
</div>

<script type="text/javascript" src="/js/shCore.js"></script>
<script type="text/javascript" src="/js/shBrushPhp.js"></script>
<script type="text/javascript" src="/js/shBrushJScript.js"></script>
<script type="text/javascript" src="/js/shBrushSql.js"></script>
<script type="text/javascript" src="/js/shBrushXml.js"></script>
<link href="/css/shCore.css" rel="stylesheet" type="text/css" />
<link href="/css/shThemeDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
     SyntaxHighlighter.all();
</script>
